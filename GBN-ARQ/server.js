// این قسمت کد مربوط به سرور می باشد
//می توان این قسمت را مستقل از کلاینت بر روی یک سرور یا یک دستکاه دیگر اجرا کرد و قابلیت سرور بودن را دارد

console.log("///////////////////////\n Server - GBN ARQ\n///////////////////////\n")


// برای اتصال از سوکت استفاده میکنیم به همین دلیل پکیج ساکت آی او را به یک متفیر نسبت می دهیم
var io = require('socket.io')
var server = io(8000) // از آدرس لوکال هاست و پورت ۸۰۰۰ برای اتصال استفاده می کنیم

// پیامی که میخواهیم ارسال کنیم طول پنجره و تعداد بایت های فریم را به عنوان پارامتر می دهیم
// هنگام اجرا این مقادیر را با دستور بر روی ترمینال اجرا می کنیم
var message = process.argv[4]
const num = parseInt(process.argv[2])
const N = parseInt(process.argv[3])

// در اینجا سرور سوکت منتظر اتصال یک کلاین به آن می شود
server.on("connection", async (socket) => { // اگر کلاینتی وصل شد این تابع اجرا می شود
    console.info(`Client connected [id=${socket.id}]\n`); // نشان می دهد یک کلاینت وصل شده است
    socket.on("disconnect", () => { // در صورتی که کلاینت دیسکانکت شود پیامی نشان داده می شود
        console.info(`Client gone [id=${socket.id}]`); // که کلاینت با این آیدی دیسی شده است
    });

     // در اینجا یک تابع می سازیم که فرستادن را شبیه سازی می کند
    async function send(seq, frame){ // دو متغیر فریم و شماره دنباله را میگیرد
        await sleep(10*frame.length) // ابتدا برای قرار دادن هر بیت بر روی مدیا ۱۰ نانو ثانیه وقت میگیرد
        output(frame, message.substring(seq * num, (seq+1)*num), seq) // سپس چاپ می کند که این فریم با این شماره فرستاده شده است
        socket.emit('media',frame) // برای فرستادن در سوکت از تابع امیت استفاده می کنیم و در کانالی به اسم مدیا میفرستیم
    }

    // در اینجا سوکت به کانال مدیا گوش میدهد در صورتی که فریمی دریافت کند تابع زیر اجرا می شود
    socket.on('media', async (frame)=>{
        await sleep(2000) // در اینجا مدت زمان انتشار شبیه سازی شده که ۲ ثانیه می باشد
        output(frame) // سپس چاپ می شود که چه مقداری را گرفته است
        received_ack(frame) // سپس فریمی که گرفته ایم را به این تابع می دهیم تا عملیات لازم انجام شود
    })

    //////////// بخش بالا موارد پیش فرض بودند 
    //////////// در این بخش کد های مربوط به این پروتکل را می نویسیم

    frames = create_frames(message, num) // ابتدا طول بایت هایی که میخواهیم بفرستیم و خود پیام را به این تابع می دهیم
                                         // تا برایمان آرایه ای از فریم هایی که باید بفرستیم بسازد و در فریمز ذخیره می کنیم
    console.log("Frames: " , frames) //  در ابتدای برنامه این آرایه را چاپ میکنیم
    index = 0 // ایندکس اندیس مربوط به فریمی است که در آن لحظه باید بفرستیم
    base = 0 // بیس اندیس مربط به فریمی است که اولین فریم پنجره مان می باشد
    status = true // نشان می دهد که وضعیت فرستادن ادامه دارد یا نه
    
    console.time("\n transmission Time: "); // تایم اجرا را به وسیله ی این تابع حساب میکنیم ابتدای تایم اینجا می باشد

    tm = timeout() // یک تایم اوت ساخته می شود و ذخیره می کنیم در ابتدای ارسال
    while(status){ // تا وقتی که وضعیت ارسال ادامه دارد فریم هارا می فرستیم
        if(index < frames.length && index < base + N){ // تا وقتی که از پنجره بیرون نرفته یا از طول همه فریم ها بیشتر نشده بفرست
            // if(Math.random() < 0.8)
                send(index, frames[index]) // فرستادن را با صدا زدن این تابع که در بالا ساخته بودیم انجام می دهیم
            index += 1 // پس از ارسال اندیس را یکی جلو می بریم
        }
        await sleep(500); // نیم ثانیه بین ارسال هایمان فاصله می اندازیم
    }

    function received_ack(frame){ // در صورتی که سرور دریافت کند این تابع اجرا می شود
        ack = frame[0] // اولین بیت از فریم ارسالی مربوط به این است که ایا آماده دریافت است یا ریجکت شده است
        seqnum = parseInt(frame.substring(1,9),2) // بقیه ی بیت ها شماره فریم می باشد که می خواهد اطلاع دهد

        clearTimeout(tm) // با گرفتن بازخورد از کلاینت تایم اوت را پاک می کنیم
        if (ack == 1){ // اگر مقدار تک بیت یک بود یعنی آماده دریافت فریم با شماره داده شده می باشد
            // بنابر این همه ی فریم های قبلی به درستی دریافت شده اند
            base = seqnum // مقدار فریم را پایه ی پنجره ذخیره می کنیم و همان اندیس های قبلی را برای ارسال ادامه می دهیم
        }else{ // در صورتی که ریجکت شده باشد
            base = seqnum // باز هم شماره را در پایه ذخیره می کنیم و می دانیم که فریم های قبلی را دریافت کرده است
            index = seqnum // اما در اینجا باید از همان اندیس ریجکت شده ینی اول پنجره باز ارسال کنیم 
        }
        tm = timeout() // سپس یک تایم اوت ست می کنیم

        if(seqnum == frames.length){ // اگر آماده دریافت فریم بعد از آخر (فریمی با اندیسی برابر تعداد فریم ها) بود ینی تمام شده است
            clearTimeout(tm) // تایم اوت را پاک می کنیم
            console.timeEnd("\n transmission Time: "); // زمان را از لحظه ی شروع کم کرده و نشان می دهد
            socket.emit('finished') // در کانال اتمام یک پیام می فرستد که به گرفتن اتمام دهد
            status = false // وضعیت ارسال را عوض می کنیم
        }
    }

    function timeout(){ // یک تایم اوت می سازد و آن را بر می گرداند
        return setTimeout(async () => {
            console.log("*** Time Out ***") // در صورتی که زمان بگذرد این تابع اجرا می شود
            index = base // از اول پنجره شروع به ارسال می کند
            tm = timeout() // و دوباره یک تایم اوت دیگر می سازد
        }, 10000); // زمان تایم اوت ۱۰ ثانیه است
    }
});


function create_frames(str, num){ // این تابع رشته و تعداد بایت های هر فریم را می گیرد
    frames = [] // ارایه ای برای فریم ها می سازد
    for (let i = 0; i< str.length; i+=num){ // برای هر چند کاراکتر این کار را انجام می دهد :و
        frame = "" // فریم خالی
        index_bin = (i/num).toString(2) // اندیس شروع که برابر اندیس کاراکتر بر تعداد است را به مبنای دو تبدیل می کند
        frame += ('00000000' + index_bin).slice(-8) // این اندیس را در هشت بیت جا می دهد و در ابتدای فریم می گذارد

        for(let j=i; j<i+num; j++){ // سپس برای تعداد بایت هایی که مشخص کرده ایم
            if(j < str.length){ // اگر کاراکتری بود
                char_bin = str.charCodeAt(j).toString(2)  // یک کاراکتر میگیرد و به یک باینری تبدیل می کند
                frame += ('00000000' + char_bin).slice(-8) // آنرا در هشت بیت جا می دهد و به فریم اضافه می کند
            }else{ // اگر کاراکتری نبود و رشته تمام شده بود بایت ۰ میفرستد
                frame += '00000000'
            }
        }

        frames.push(frame) // فریم را به آرایه اضافه می کند
    }
    return frames // آرایه را بر می گرداند
}

function output(frame, char, seq){ // برای نمایش خروجی می باشد اهمیتی ندارد :D
    if(typeof seq !== "undefined") {
        console.log("-" + getTime() + " | SENT | " + "SEQ: " + seq +  " | Msg: " + char + " | " + "Frame: " + frame)
    }else{
        if(frame[0] == 0){
            console.log("-" + getTime() + " | RECV | " + "REJ: " + frame)
        }else{
            console.log("-" + getTime() + " | RECV | " + "RR: " + frame)
        }
    }
}

function sleep(ms) { // ساخت تابع اسلیپ با استفاده از پرامیس و یک تایم اوت صورت می گیرد
    return new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
}

function getTime(){ // زمان را با فرمت مناسبی بر می گرداند
    return new Date().toISOString().slice(11,23)
}